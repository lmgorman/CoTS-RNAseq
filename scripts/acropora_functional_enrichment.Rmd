---
title: "acropora_functional_enrichment"
author: "LM Gorman, AS Huffmyer"
date: "2025-03-28"
output:
  html_document:
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    keep_tex: yes
editor_options: 
  chunk_output_type: console
---




# Set up 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# The following setting is important, do not omit.
options(stringsAsFactors = FALSE) #Set Strings to character
```

```{r}
if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse') 
if ("genefilter" %in% rownames(installed.packages()) == 'FALSE') install.packages('genefilter') 
if ("DESeq2" %in% rownames(installed.packages()) == 'FALSE') install.packages('DESeq2') 
if ("RColorBrewer" %in% rownames(installed.packages()) == 'FALSE') install.packages('RColorBrewer') 
#if ("WGCNA" %in% rownames(installed.packages()) == 'FALSE') install.packages('WGCNA') 
if ("flashClust" %in% rownames(installed.packages()) == 'FALSE') install.packages('flashClust') 
if ("gridExtra" %in% rownames(installed.packages()) == 'FALSE') install.packages('gridExtra') 
if ("ComplexHeatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('ComplexHeatmap') 
if ("goseq" %in% rownames(installed.packages()) == 'FALSE') install.packages('goseq') 
if ("dplyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('dplyr') 
if ("clusterProfiler" %in% rownames(installed.packages()) == 'FALSE') install.packages('clusterProfiler') 
if ("pheatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('pheatmap') 
if ("magrittr" %in% rownames(installed.packages()) == 'FALSE') install.packages('magrittr') 
if ("rtracklayer" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("rtracklayer")
if ("GenomicRanges" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("GenomicRanges")
if ("plyranges" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("plyranges")
if ("GSEABase" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("GSEABase")
#if ("GOSim" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("GOSim")
if ("stats" %in% rownames(installed.packages()) == 'FALSE') install.packages("stats")
if ("ggdendro" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("ggdendro")
if ("GO.db" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("GO.db")
if ("rrvgo" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("rrvgo")
if ("rtracklayer" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("rtracklayer")

#BiocManager::install("org.Ce.eg.db", force=TRUE) #install if needed 
library("rtracklayer")
library("tidyverse")
library("genefilter")
library("DESeq2")
library("RColorBrewer")
#library("WGCNA")
library("flashClust")
library("gridExtra")
library("ComplexHeatmap")
library("goseq")
library("dplyr")
library("clusterProfiler")
library("pheatmap")
library("magrittr")
library("rtracklayer")
library("GenomicRanges")
library("plyranges")
library("GSEABase")
#library("GOSim")
library("stats")
library("ggdendro")
library("GO.db")
library("rrvgo")
library("cowplot")
library("ape")
library("topGO")
```

# Read in data files 

1. Read in file with vst transformed counts of all genes detected and kept after filtering. 
```{r Read in all genes file}
#Need to work out which file this is from acropora_DEG script
all_genes_acr<-read.csv("data/all_genes_acr.csv", col.names = c("gene_id","trim.321ra.gtf","trim.331ra.gtf","trim.336r.gtf","trim.370r.gtf","trim.380r.gtf","trim.410r.gtf","trim.414r.gtf","trim.419r.gtf","trim.468r.gtf","trim.512r.gtf","trim.549r.gtf","trim.568r.gtf","trim.571r.gtf","trim.581r.gtf","trim.586r.gtf"))
transposed_all_genes_acr <- t(all_genes_acr)
print(transposed_all_genes_acr)
transposed_all_genes_acr <- as.data.frame(t(all_genes_acr))
# Set proper column names using row names (which were originally column headers)
colnames(transposed_all_genes_acr) <- transposed_all_genes_acr[1, ]  # First row as column names
transposed_all_genes_acr <- transposed_all_genes_acr[-1, ] 
```

2. Read in file of DEG's between eaten and control
```{r read in file of DEGs}
acr_eatenvscontrol_DEG_list<-read.csv("data/DEG_acr.csv")
acr_eatenvscontrol_DEG_list$contrast<-factor(acr_eatenvscontrol_DEG_list$contrast, levels=c("eaten", "control"))
```

# Read in annotation files 
Will use the structural genome annotations done in the google drive for *A. hyacinthus* (LÃ³pez-Nandam et al., 2023; https://royalsocietypublishing.org/doi/10.1098/rspb.2022.1766). This paper used MAKER2 for genome annotation. I think the annotation file is called: Ahyacinthus_transcripts_b2g-annotated_blast-nr-results.txt - it is but it contains many missing GO terms

NB:Many scientists use funannotate package in R (https://funannotate.readthedocs.io/en/latest/index.html) to run functional enrichment of genomes.
funannotate - Script functionally annotates the results from funannotate predict.  It pulls annotation from PFAM, InterPro, EggNog, UniProtKB, MEROPS, CAZyme, and GO ontology.


Conduct functional enrichment using goseq and rrvgo. Compare against all genes detected in the dataset that we have annotation information for.

I need to use the genome annotations from google drive to compare against my geneset. Below is Ariana's script from https://github.com/AHuffmyer/EarlyLifeHistory_Energetics/blob/master/Mcap2020/Scripts/TagSeq/DESeq2_Mcap_V3.Rmd. I need to paste my relevant documents and data. Ariana clustered her data during this - do I need to do that too?

```{r functional annotation files from Lopez Nandam}
Ahya_annot <- read.delim("data/Ahyacinthus_transcripts_b2g-annotated_blast-nr-results.txt",  header=TRUE, na.strings = "---NA---")
dim(Ahya_annot)
#[1] 27110    15
```

```{r, Need to remove RA at the end of all the SeqNames so it matches to gene in acr_eatenvscontrol_DEG}
Ahya_annot <- Ahya_annot %>%
  mutate(SeqName = str_remove(SeqName, "-RA")) 
```
LopezNandam functional annotation has 27110 genes. 
SeqNames now match the gene vairable in both files.
```{r}
# look at variable names
names(Ahya_annot)
probes = colnames(transposed_all_genes_acr)
seq_name = Ahya_annot$SeqName
#match genes in all_genes_acr to genes in annotation file (Ahya_annot)
probes_in_annot = probes %in% seq_name
seqname_in_probes_df <- data.frame(
  InProbes = seq_name %in% probes,
  row.names = seq_name
)

View(seqname_in_probes_df) #match genes (SeqName)to genes in annotation file.

# The following is the number of probes without annotation 
sum(probes_in_annot == FALSE) #0
sum(probes_in_annot == TRUE) #18258 = all genes found in annotation file - yayy!
sum(seqname_in_probes_df == FALSE) #8852
sum(seqname_in_probes_df == TRUE)#18258

#Create new variable saying when genes are missing from the dataframe
seqname_in_probes_df <- seqname_in_probes_df %>%
  mutate(missing_genes =
         case_when(
           seqname_in_probes_df == "FALSE" ~ "YES"
           )
         )
print(seqname_in_probes_df)

#Now use this column and row names to filter the larger data frame of gene annotations (Ahya_annot) to only include our genes found in our A. hyacinthus RNASeq
missing_gene_list <- seqname_in_probes_df %>%
  filter(missing_genes == "YES")
dim(missing_gene_list) #8852 as expected - great
#Now create a filtered gene set taking away the missing_gene_list from the annotated gene list
Ahya_annot_seq_name_filtered <- Ahya_annot %>% 
  filter(!(SeqName %in% rownames(missing_gene_list)))
dim(Ahya_annot_seq_name_filtered) #18258 - as expected
```

Reduced annotation file to only contain genes detected in our dataset.  

Now file only contains the 18258 genes after filtering. This is 18258 out of the 27110 genes in our dataset. 

Add in length to the annotation file.   

Get gene length information.  
```{r}
#import file
#Not sure which file to import into R? there are .gff and .gff3 files both in the /data directory.
gff <- rtracklayer::import("data/Ahyacinthus.coding.gff3") #if this doesn't work, restart R and try again 


transcripts <- subset(gff, type == "mRNA") #keep only transcripts 


transcripts_gr <- makeGRangesFromDataFrame(transcripts, keep.extra.columns=TRUE) #extract length information

transcript_lengths <- width(transcripts_gr) #isolate length of each gene

seqnames<-transcripts_gr$ID #extract list of gene id 

lengths<-cbind(seqnames, transcript_lengths)

lengths<-as.data.frame(lengths) #convert to data frame
#remove unwanted character strings from the length dataframe
lengths <- lengths %>%
  mutate(seqnames = str_remove(seqnames, "-RA"))
#make seqnames lower case to make same as other data frames
lengths <- lengths %>%
  mutate(seqnames = tolower(seqnames))

#try with read gff function for length - looks same as code above
#gff_2 <- read.gff("data/Ahyacinthus.coding.gff3", na.strings = c(".", "?"), GFF3 = TRUE)
#transcripts_2 <- subset(gff_2, type == "mRNA")
#transcripts_2 <- transcripts_2 %>%
  #mutate(length = end - start) %>%
  #View()
```

Already has a lengths variable in Ahya_annot_seq_name_filtered. 
```{r}
Ahya_annot_seq_name_filtered$length<-lengths$transcript_lengths[match(Ahya_annot_seq_name_filtered$SeqName, lengths$seqnames)]

which(is.na(Ahya_annot_seq_name_filtered$length)) #all genes have lengths 
```

```{r, Lucys functional annotation}
Ahya_annot_lucy <- read.delim("data/Acropora_hyacinthus.annotations.txt",  header=TRUE, na.strings = "---NA---")
dim(Ahya_annot_lucy)
```
[1] 27110    26

SeqNames now match the gene vairable in both files.
```{r}
# look at variable names
names(Ahya_annot_lucy)
#remove sample column name 
seq_name_lucy = Ahya_annot_lucy$GeneID

probes_in_annot_lucy = probes %in% seq_name_lucy

seqname_in_probes_df_lucy <- data.frame(
  InProbes = seq_name_lucy %in% probes,
  row.names = seq_name_lucy
)

View(seqname_in_probes_df_lucy)

# The following is the number of probes without annotation 
sum(probes_in_annot_lucy == FALSE) #0
sum(probes_in_annot_lucy == TRUE) #18258 = all genes found in annotation file - yayy!
sum(seqname_in_probes_df_lucy == FALSE) #8852
sum(seqname_in_probes_df_lucy == TRUE)#18258

#Create new variable saying when genes are missing from the dataframe
seqname_in_probes_df_lucy <- seqname_in_probes_df_lucy %>%
  mutate(missing_genes =
         case_when(
           seqname_in_probes_df_lucy == "FALSE" ~ "YES"
           )
         )
print(seqname_in_probes_df_lucy)

########
#Now use this column and row names to filter the larger data frame of gene annotations (Ahya_annot) to only include our genes found in our A. hyacinthus RNASeq
missing_gene_list_lucy <- seqname_in_probes_df_lucy %>%
  filter(missing_genes == "YES")
dim(missing_gene_list_lucy) #8852 as expected - great
#Now create a filtered gene set taking away the missing_gene_list from the annotated gene list
Ahya_annot_seq_name_filtered_lucy <- Ahya_annot_lucy %>% 
  filter(!(GeneID %in% rownames(missing_gene_list_lucy)))
dim(Ahya_annot_seq_name_filtered_lucy)
```
Reduced annotation file to only contain genes detected in our dataset.  

Now file only contains the 18258 genes after filtering. This is 18258 out of the 27110 genes in our dataset. File called `Ahya_annot_seq_name_filtered_lucy`

```{r}
write.csv(Ahya_annot_seq_name_filtered_lucy,file='D:/CoTS-RNAseq/data/Ahya_annot_lucy_filtered.csv') 
```


# TopGO 

In topGO we need: 

- Ontology: character string specifying the ontology of interest (BP, MF or CC).
- allGenes: named vector of type numeric or factor. The names attribute contains the genes identifiers. The genes listed in this object define the gene universe.
- nodeSize: an integer larger or equal to 1. This parameter is used to prune the GO hierarchy from the terms which have less than nodeSize annotated genes (after the true path rule is applied).
- annotationFun: function which maps genes identifiers to GO terms. There are a couple of annotation function included in the package trying to address the userâs needs. The annotation functions take three arguments. One of those arguments is specifying where the mappings can be found, and needs to be provided by the user. annFUN.gene2GO this function is used when the annotations are provided as a gene-to-GOs mapping.

Background/GO information: 
```{r}
geneID2GO<-Ahya_annot_seq_name_filtered_lucy 
geneID2GO_df <- as.data.frame(geneID2GO)
background<-geneID2GO_df%>%pull("GeneID")

#remove genes with NA in go term and separate rows based on GO terms 
geneID2GO_df<-geneID2GO_df%>%
  filter(!(GO.Terms == ""))%>%
  separate_rows(GO.Terms, sep = ";")
#creates list with each GO term appended to the geneID
geneID2GO_df <- split(as.character(geneID2GO_df$GO.Terms), geneID2GO_df$GeneID)
```

Annotation setting: annFUN.gene2GO 

nodeSize = 5; this setting prunes GO terms that have <5 annotated genes associated with this GO term. "It is often the case that many GO terms which have few annotated genes are detected to be significantly enriched due to artifacts in the statistical test. These small sized GO terms are of less importance for the analysis and in many cases they can be omitted. By using the nodeSize argument the user can control the size of the GO terms used in the analysis. Once the genes are annotated to the each GO term and the true path rule is applied the nodes with less than nodeSize annotated genes are removed from the GO hierarchy. We found that values between 5 and 10 for the nodeSize parameter yield more stable results. The default value for the nodeSize parameter is 1, meaning that no pruning is performed." - TopGO documentation 

Run TopGO

```{r}
acr_test_set<-acr_eatenvscontrol_DEG_list%>%pull(gene_ID)
# 1. Make sure background is a character vector
background <- as.character(background)
# 2. Make sure acr_test_set is character too
acr_test_set <- as.character(acr_test_set)
# 3. Build geneList as a named factor
geneList <- factor(background %in% acr_test_set, levels = c(FALSE, TRUE))
# 4. Check structure
str(geneList)
#Make sure the geneList is an integer NOT a logical
geneList <- as.integer(background %in% acr_test_set)
names(geneList) <- background
table(geneList) 
#should look like:
# geneList
#    0     1 
# 16853  1405 

str(geneID2GO_df, max.level = 1)
head(geneID2GO_df, 3)
sum(names(geneList) %in% names(geneID2GO_df))

# Extract GO IDs from the strings
extractGO <- function(go_strings) {
  # Extract patterns like "GO:0000001"
  unique(unlist(regmatches(go_strings, gregexpr("GO:\\d{7}", go_strings))))
}

# Apply to your list
gene2GO <- lapply(geneID2GO_df, extractGO)
str(gene2GO, max.level = 1)


GOdata <- new("topGOdata",
              description = "acr_DEGs",
              ontology = "BP",
              allGenes = geneList,
              geneSelectionFun = function(x) x == 1,
              nodeSize = 5,
              gene2GO = gene2GO, annot = annFUN.gene2GO) #Gene

GOdata
numSigGenes(GOdata) #652 sig genes
sum(feasible(GOdata)) #8095 genes used in analysis as background
```

Run fisher test. 
```{r}
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
resultFisher
hist(score(resultFisher), 50, xlab = "p-values")

#82 terms with p<0.01

resultWeight <- runTest(GOdata, algorithm = "weight01", statistic = "fisher")
resultWeight
hist(score(resultWeight), 50, xlab = "p-values")
#20 terms with p<0.01

# p < 0.05 for weighted fisher
#Generate GO term table from resultWeight
allGO <- GenTable(GOdata,
                  weight01Fisher = resultWeight,
                  orderBy = "weight01Fisher",
                  topNodes = 1000)  # get many to filter later

# Convert p-values to numeric
allGO$weight01Fisher <- as.numeric(allGO$weight01Fisher)

# Filter for p < 0.05
signifGO <- subset(allGO, weight01Fisher < 0.05)

# See how many significant terms
nrow(signifGO) #40 GO terms
head(signifGO)

#p<0.05 for classic fisher
classicGO <- GenTable(GOdata,
                      classicFisher = resultFisher,
                      orderBy = "classicFisher",
                      topNodes = 1000)

classicGO$classicFisher <- as.numeric(classicGO$classicFisher)
signifClassic <- subset(classicGO, classicFisher < 0.05)

nrow(signifClassic)#126 GO terms
head(signifClassic)
```

Which test should be used? 
#Need to work this out from new p values, chat to Ariana

```{r}
allRes <- GenTable(GOdata, classicFisher = resultFisher, weightFisher = resultWeight, orderBy = "weightFisher", ranksOf = "classicFisher", topNodes = length(score(resultFisher)))

# Convert character columns to numeric
allRes$classicFisher <- as.numeric(allRes$classicFisher)
allRes$weightFisher <- as.numeric(allRes$weightFisher)

#adjust p-values 
allRes$bh_adjust <- p.adjust(allRes$classicFisher, method="BH") #add adjusted p-values

#adjust p-values 
allRes$bh_adjust_weight <- p.adjust(allRes$weightFisher, method="BH") #add adjusted p-values
```

```{r}
showSigOfNodes(GOdata, score(resultFisher), firstSigNodes = 5, useInfo = 'def')
dev.off()

showSigOfNodes(GOdata, score(resultWeight), firstSigNodes = 5, useInfo = 'def')
dev.off()
```

The subgraph induced by the top 5 GO terms identified by the classic algorithm for scoring GO terms for enrichment. Boxes indicate the 5 most significant terms. Box color represents the relative significance, ranging from dark red (most significant) to light yellow (least significant). Black arrows indicate is-a relationships and red arrows part-of relationships.

Proceed using weighted fisher test results.  
```{r}
p05_res <- allRes %>% dplyr::filter(weightFisher < 0.05)
  
#Reduce/collapse GO term set with the rrvgo package 
simMatrix <- calculateSimMatrix(p05_res$GO.ID,
                                orgdb="org.Ce.eg.db", #c. elegans database
                                ont="BP",
                                method="Rel")
```

```{r}
 #calculate similarity 
scores <- setNames(-log(as.numeric(p05_res$weightFisher)), p05_res$GO.ID)
reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Ce.eg.db")
dim(reducedTerms)# 38 10
```

```{r}
#keep only the goterms from the reduced list
p05_res_reduced <- p05_res %>%
  filter(GO.ID %in% reducedTerms$go)

#add in parent terms to list of go terms 
p05_res_reduced$ParentTerm <- reducedTerms$parentTerm[match(p05_res_reduced$GO.ID, reducedTerms$go)]

length(unique(p05_res_reduced$ParentTerm))#12

p05_res_reduced <- p05_res_reduced %>% group_by(ParentTerm) %>% mutate("N_in_Parent" = dplyr::n()) %>% ungroup()
length(unique(p05_res_reduced$ParentTerm)) #18
```

```{r}
write.csv(p05_res_reduced, "output/parent_topGO_results.csv")
```

```{r}
parent_enrich_plot1 <- ggplot(p05_res_reduced, aes(x=weightFisher,y=reorder(Term,weightFisher)))+
  facet_grid(ParentTerm ~ ., scales="free", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
  geom_point(size=2, color="black")+
  geom_segment(aes(x=0, xend=weightFisher, y=Term, yend=Term)) +
  #geom_hline(yintercept = 0, linetype="solid", color = 'black', linewidth=0.5, show.legend = TRUE)+
  #scale_y_continuous(limits=c(0,40))+
   #scale_x_discrete(labels = label_wrap(30)) +
  #scale_fill_gradientn(colours=c("white","#fddbc7","#f4a582","#d6604d","#b2182b"), na.value = "grey98",limits = c(0, 100)) +
  #labs(title = "Enriched Biological Process Parent GO Terms, Brown Module", x="Parent Term", y="Number of Significant (p < 0.01) GO Terms in Module", colour="p-value") +
  theme_classic() + 
  theme(axis.text.y = element_text(size = 8), 
              axis.title = element_text(size = 8), 
              plot.title = element_text(hjust = 0.5, size = 8));parent_enrich_plot1

ggsave("figures/acropora/parent_enrich_plot1.pdf", plot = parent_enrich_plot1, width = 8, height = 6, units = "in")
dev.off()  # close and save

```